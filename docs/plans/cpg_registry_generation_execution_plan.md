# CPG Registry Generation Execution Plan

## Goals
- Make all derived CPG registry artifacts generated by `src/storage/deltalake/cpg_registry.py`.
- Ensure CPG consumers load from registry tables (Arrow/Delta) instead of static declarations.
- Keep independent specs in `src/cpg` (and rule specs in `src/relspec`) as canonical inputs.
- Support both pipeline and on-demand registry generation with identical outputs.

## Non-goals
- Changing the semantics of the independent CPG specs.
- Changing relspec rule semantics during the move.
- Introducing a CLI surface (runner remains module-only).

## Scope Item 1: Expand CPG registry outputs to cover derived artifacts
### Representative pattern
```python
# src/storage/deltalake/cpg_registry.py
REGISTRY_TABLE_SPECS = (
    RegistryTableSpec(
        name="cpg_dataset_rows",
        builder=dataset_rows_table,
        description="CPG dataset row declarations.",
    ),
    RegistryTableSpec(
        name="cpg_field_catalog",
        builder=field_catalog_table,
        description="CPG field catalog definitions.",
    ),
    RegistryTableSpec(
        name="cpg_bundle_catalog",
        builder=bundle_catalog_table,
        description="CPG field bundle catalog.",
    ),
    RegistryTableSpec(
        name="cpg_registry_templates",
        builder=registry_templates_table,
        description="CPG registry template defaults.",
    ),
)
```

```python
# src/cpg/registry_tables.py (or new cpg/registry_outputs.py)
DATASET_ROW_SCHEMA = pa.schema(
    [
        pa.field("name", pa.string(), nullable=False),
        pa.field("version", pa.int32(), nullable=False),
        pa.field("bundles", pa.list_(pa.string()), nullable=False),
        pa.field("fields", pa.list_(pa.string()), nullable=False),
        pa.field("template", pa.string(), nullable=True),
        pa.field("contract_name", pa.string(), nullable=True),
    ],
    metadata={b"spec_kind": b"cpg_dataset_rows"},
)

def dataset_rows_table() -> pa.Table:
    rows = [
        {
            "name": row.name,
            "version": row.version,
            "bundles": list(row.bundles),
            "fields": list(row.fields),
            "template": row.template,
            "contract_name": row.contract_name,
        }
        for row in DATASET_ROWS
    ]
    return table_from_rows(DATASET_ROW_SCHEMA, rows)
```

### Target files
- `src/storage/deltalake/cpg_registry.py`
- `src/cpg/registry_tables.py` (or new `src/cpg/registry_outputs.py`)
- `src/cpg/registry_rows.py`
- `src/cpg/registry_fields.py`
- `src/cpg/registry_bundles.py`
- `src/cpg/registry_templates.py`

### Implementation checklist
- [ ] Define Arrow schemas for `cpg_dataset_rows`, `cpg_field_catalog`, `cpg_bundle_catalog`, `cpg_registry_templates`.
- [ ] Add table builders that serialize current row/catalog/template objects into Arrow tables.
- [ ] Add the new table specs to `REGISTRY_TABLE_SPECS` in `src/storage/deltalake/cpg_registry.py`.
- [ ] Ensure `spec_kind` metadata matches the registry table name for each schema.

## Scope Item 2: Introduce CPG registry decoders/readers
### Representative pattern
```python
# src/cpg/registry_readers.py
from arrowdsl.schema.build import iter_rows_from_table


def dataset_rows_from_table(table: pa.Table) -> tuple[DatasetRow, ...]:
    rows: list[DatasetRow] = []
    for row in iter_rows_from_table(table):
        rows.append(
            DatasetRow(
                name=str(row["name"]),
                version=int(row["version"]),
                bundles=tuple(row.get("bundles") or ()),
                fields=tuple(row.get("fields") or ()),
                template=_opt_str(row.get("template")),
                contract_name=_opt_str(row.get("contract_name")),
            )
        )
    return tuple(rows)
```

### Target files
- `src/cpg/registry_readers.py` (new)
- `src/cpg/contract_registry.py`
- `src/cpg/registry_tables.py`

### Implementation checklist
- [ ] Add decoders for dataset rows, field catalog entries, bundle catalog entries, and templates.
- [ ] Add decoders for contract and derivation tables (if not already present).
- [ ] Centralize row coercion helpers (safe str/int/bool conversions).
- [ ] Keep decoder outputs identical to current in-memory objects.

## Scope Item 3: Refactor contract and derivation accessors to read registry tables
### Representative pattern
```python
# src/cpg/contract_registry.py
from storage.deltalake.delta import read_table_delta
from cpg.registry_readers import (
    edge_contracts_from_table,
    node_contracts_from_table,
    derivations_from_table,
)

def load_contracts_from_registry(path: PathLike) -> ContractRegistry:
    node_table = read_table_delta(path / "registry" / "cpg" / "cpg_node_contracts")
    edge_table = read_table_delta(path / "registry" / "cpg" / "cpg_edge_contracts")
    deriv_table = read_table_delta(path / "registry" / "cpg" / "cpg_kind_derivations")
    return ContractRegistry(
        node_contracts=node_contracts_from_table(node_table),
        edge_contracts=edge_contracts_from_table(edge_table),
        derivations=derivations_from_table(deriv_table),
    )
```

### Target files
- `src/cpg/contract_registry.py`
- `src/cpg/registry_tables.py`
- `src/storage/deltalake/cpg_registry.py`

### Implementation checklist
- [ ] Add registry-table loaders for node/edge contracts and derivations.
- [ ] Keep cache behavior but swap static builders for registry reads.
- [ ] Ensure `validate_registry_completeness` can accept registry tables.

## Scope Item 4: Refactor dataset spec plumbing to read from registry tables
### Representative pattern
```python
# src/cpg/registry_specs.py
from cpg.registry_readers import dataset_rows_from_table
from cpg.registry_tables import dataset_rows_table

@cache
def dataset_rows() -> tuple[DatasetRow, ...]:
    table = dataset_rows_table()  # local fallback
    return dataset_rows_from_table(table)
```

```python
# src/cpg/schemas.py
from cpg.registry_readers import dataset_schema_from_registry

CPG_NODES_SCHEMA = dataset_schema_from_registry("cpg_nodes_v1")
```

### Target files
- `src/cpg/registry_builders.py`
- `src/cpg/registry_specs.py`
- `src/cpg/schemas.py`
- `src/cpg/registry_fields.py`
- `src/cpg/registry_bundles.py`
- `src/cpg/registry_templates.py`

### Implementation checklist
- [ ] Add registry-backed dataset row accessors (read from registry tables).
- [ ] Update schema and contract accessors to build from registry-backed rows.
- [ ] Keep a local fallback path for unit tests (in-memory tables).
- [ ] Preserve existing metadata in `SchemaMetadataSpec`.

## Scope Item 5: Align CPG edge plan specs to relspec registry outputs
### Representative pattern
```python
# src/cpg/edge_specs.py
from relspec.rules.spec_tables import rule_definitions_from_table
from storage.deltalake.delta import read_table_delta


def edge_plan_specs_from_registry(path: PathLike) -> tuple[EdgePlanSpec, ...]:
    rule_table = read_table_delta(path / "registry" / "relspec" / "relspec_rule_definitions")
    definitions = rule_definitions_from_table(rule_table)
    return edge_plan_specs_from_definitions(definitions)
```

### Target files
- `src/cpg/edge_specs.py`
- `src/cpg/registry.py`
- `src/storage/deltalake/relspec_registry.py`

### Implementation checklist
- [ ] Update edge plan spec builders to consume the relspec rule registry table.
- [ ] Remove direct dependence on CPG-local rule template specs (after move to relspec).
- [ ] Verify the rule table domain filter still produces only CPG edges.

## Scope Item 6: Wire registry generation for pipeline and on-demand usage
### Representative pattern
```python
# src/graph/product_build.py
from storage.deltalake.registry_runner import run_registry_exports

registry_output_dir = _resolve_output_dir(repo_root, output_dir)
run_registry_exports(registry_output_dir)
```

```python
# src/storage/deltalake/registry_runner.py
run_registry_exports(output_dir, targets=("cpg", "relspec"))
```

### Target files
- `src/graph/product_build.py`
- `src/storage/deltalake/registry_runner.py`

### Implementation checklist
- [ ] Ensure pipeline calls the same registry runner as on-demand usage.
- [ ] Confirm registry outputs are under `output_dir/registry/cpg` and `output_dir/registry/relspec`.
- [ ] Add docstring examples showing expected output paths.

## Scope Item 7: Parity verification and cleanup
### Representative pattern
```python
# tests/unit/test_cpg_registry_parity.py

def assert_table_equal(left: pa.Table, right: pa.Table) -> None:
    if not left.schema.equals(right.schema, check_metadata=True):
        msg = "Schema mismatch"
        raise AssertionError(msg)
    if left.to_pylist() != right.to_pylist():
        msg = "Row mismatch"
        raise AssertionError(msg)
```

### Target files
- `tests/unit/test_cpg_registry_parity.py` (new)
- `src/cpg/registry_tables.py`
- `src/storage/deltalake/cpg_registry.py`

### Implementation checklist
- [ ] Compare each derived table to the registry-generated equivalent.
- [ ] Validate relspec rule table parity for edge plan specs.
- [ ] Remove static derivations once parity is established.

## Deliverables
- CPG registry now emits all derived artifacts as Delta-backed tables.
- CPG consumers load from registry outputs (or local fallback tables in tests).
- Relspec rule definitions and templates are centralized and consumed by CPG edge planning.
- Pipeline and on-demand paths are aligned through the registry runner.
