from collections.abc import Sequence
from typing import Self, overload

from pyarrow import Array, ChunkedArray, Scalar

class Expression:
    def __and__(self, other: Expression) -> Expression: ...
    def __rand__(self, other: Expression) -> Expression: ...
    def __iand__(self, other: Expression) -> Self: ...
    def __or__(self, other: Expression) -> Expression: ...
    def __ror__(self, other: Expression) -> Expression: ...
    def __ior__(self, other: Expression) -> Self: ...
    def __invert__(self) -> Expression: ...
    def __eq__(self, other: object) -> Expression: ...
    def __ne__(self, other: object) -> Expression: ...
    def __lt__(self, other: object) -> Expression: ...
    def __le__(self, other: object) -> Expression: ...
    def __gt__(self, other: object) -> Expression: ...
    def __ge__(self, other: object) -> Expression: ...
    def isin(self, values: Sequence[object]) -> Expression: ...
    def is_null(self) -> Expression: ...
    def is_valid(self) -> Expression: ...

def field(name: str) -> Expression: ...
def scalar(value: object) -> Expression: ...
@overload
def cast(expr: Expression, target_type: object, *, safe: bool = True) -> Expression: ...
@overload
def cast(
    expr: Array | ChunkedArray | Scalar, target_type: object, *, safe: bool = True
) -> Array: ...
def coalesce(*args: Expression) -> Expression: ...
@overload
def is_null(expr: Expression) -> Expression: ...
@overload
def is_null(expr: Array | ChunkedArray) -> Array: ...
@overload
def is_valid(expr: Expression) -> Expression: ...
@overload
def is_valid(expr: Array | ChunkedArray) -> Array: ...
@overload
def invert(values: Expression) -> Expression: ...
@overload
def invert(values: Array) -> Array: ...
def value_counts(values: Array | ChunkedArray) -> Array: ...
def sort_indices(table: object, *, sort_keys: Sequence[tuple[str, str]]) -> Array: ...
@overload
def equal(left: Expression, right: Expression | Array | ChunkedArray | Scalar) -> Expression: ...
@overload
def equal(left: Array | ChunkedArray | Scalar, right: Expression) -> Expression: ...
@overload
def equal(left: Array | ChunkedArray | Scalar, right: Array | ChunkedArray | Scalar) -> Array: ...
@overload
def or_(left: Expression, right: Expression) -> Expression: ...
@overload
def or_(left: Array, right: Array) -> Array: ...
def fill_null(values: Array, replacement: bool) -> Array: ...
def list_parent_indices(values: Array | ChunkedArray) -> Array: ...
def list_flatten(values: Array | ChunkedArray) -> Array: ...
def take(values: Array | ChunkedArray, indices: Array) -> Array: ...
