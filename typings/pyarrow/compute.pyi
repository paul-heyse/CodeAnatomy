from collections.abc import Mapping, Sequence
from typing import Self, overload

from pyarrow import Array, ChunkedArray, DataType, Scalar

class UdfContext: ...

class Expression:
    def __and__(self, other: Expression) -> Expression: ...
    def __rand__(self, other: Expression) -> Expression: ...
    def __iand__(self, other: Expression) -> Self: ...
    def __or__(self, other: Expression) -> Expression: ...
    def __ror__(self, other: Expression) -> Expression: ...
    def __ior__(self, other: Expression) -> Self: ...
    def __invert__(self) -> Expression: ...
    def __eq__(self, other: object) -> Expression: ...
    def __ne__(self, other: object) -> Expression: ...
    def __lt__(self, other: object) -> Expression: ...
    def __le__(self, other: object) -> Expression: ...
    def __gt__(self, other: object) -> Expression: ...
    def __ge__(self, other: object) -> Expression: ...
    def isin(self, values: Sequence[object]) -> Expression: ...
    def is_null(self) -> Expression: ...
    def is_valid(self) -> Expression: ...

def field(name: str) -> Expression: ...
def scalar(value: object) -> Expression: ...
@overload
def cast(expr: Expression, target_type: object, *, safe: bool = True) -> Expression: ...
@overload
def cast(
    expr: Array | ChunkedArray | Scalar, target_type: object, *, safe: bool = True
) -> Array: ...
@overload
def coalesce(*args: Expression) -> Expression: ...
@overload
def coalesce(*args: Array | ChunkedArray | Scalar) -> Array: ...
@overload
def is_null(expr: Expression) -> Expression: ...
@overload
def is_null(expr: Array | ChunkedArray) -> Array: ...
@overload
def is_valid(expr: Expression) -> Expression: ...
@overload
def is_valid(expr: Array | ChunkedArray) -> Array: ...
@overload
def invert(values: Expression) -> Expression: ...
@overload
def invert(values: Array) -> Array: ...
def value_counts(values: Array | ChunkedArray) -> Array: ...
def sort_indices(table: object, *, sort_keys: Sequence[tuple[str, str]]) -> Array: ...
@overload
def equal(left: Expression, right: Expression | Array | ChunkedArray | Scalar) -> Expression: ...
@overload
def equal(left: Array | ChunkedArray | Scalar, right: Expression) -> Expression: ...
@overload
def equal(left: Array | ChunkedArray | Scalar, right: Array | ChunkedArray | Scalar) -> Array: ...
@overload
def not_equal(
    left: Expression, right: Expression | Array | ChunkedArray | Scalar
) -> Expression: ...
@overload
def not_equal(left: Array | ChunkedArray | Scalar, right: Expression) -> Expression: ...
@overload
def not_equal(
    left: Array | ChunkedArray | Scalar, right: Array | ChunkedArray | Scalar
) -> Array: ...
@overload
def bit_wise_and(
    left: Expression, right: Expression | Array | ChunkedArray | Scalar
) -> Expression: ...
@overload
def bit_wise_and(left: Array | ChunkedArray | Scalar, right: Expression) -> Expression: ...
@overload
def bit_wise_and(
    left: Array | ChunkedArray | Scalar, right: Array | ChunkedArray | Scalar
) -> Array: ...
@overload
def or_(left: Expression, right: Expression) -> Expression: ...
@overload
def or_(left: Array | ChunkedArray, right: Array | ChunkedArray) -> Array: ...
@overload
def and_(left: Expression, right: Expression) -> Expression: ...
@overload
def and_(left: Array | ChunkedArray, right: Array | ChunkedArray) -> Array: ...
@overload
def if_else(
    condition: Expression,
    left: Expression | Scalar,
    right: Expression | Scalar,
) -> Expression: ...
@overload
def if_else(
    condition: Array | ChunkedArray,
    left: Array | ChunkedArray | Scalar,
    right: Array | ChunkedArray | Scalar,
) -> Array: ...
@overload
def is_in(values: Expression, *, value_set: Array | Sequence[object]) -> Expression: ...
@overload
def is_in(values: Array | ChunkedArray, *, value_set: Array | Sequence[object]) -> Array: ...
@overload
def starts_with(values: Expression, prefix: str) -> Expression: ...
@overload
def starts_with(values: Array | ChunkedArray, prefix: str) -> Array: ...
def fill_null(values: Array | ChunkedArray, replacement: object) -> Array: ...
@overload
def drop_null(values: Expression) -> Expression: ...
@overload
def drop_null(values: Array | ChunkedArray) -> Array: ...
def list_parent_indices(values: Array | ChunkedArray) -> Array: ...
def list_flatten(values: Array | ChunkedArray) -> Array: ...
def take(values: Array | ChunkedArray, indices: Array) -> Array: ...
def binary_join_element_wise(
    *strings: Array | ChunkedArray | Scalar | Expression | str,
) -> Array: ...
def call_function(
    name: str,
    args: Sequence[Array | ChunkedArray | Scalar],
) -> Array | ChunkedArray | Scalar: ...
def get_function(name: str) -> object: ...
def register_scalar_function(
    func: object,
    function_name: str,
    function_doc: Mapping[str, str],
    in_types: Mapping[str, DataType],
    out_type: DataType,
    func_registry: object | None = None,
) -> None: ...
